## 图

### 基本概念

1. 无向图 & 有向图
2. 有权图& 无权图
3. 入度 & 出度
4. 路径 & 环
5. 连通图 & 强连通图


### 图的建立

> 即使用数据结构表示图

##### 邻接矩阵方式（常见）

使用一个`n * n`的矩阵来描述图graph，其就是一个二维的矩阵，`graph[i][j] = 1`来表示顶点`i`和顶点`j`之间有一条边，用`graph[i][j] = 0`来表示顶点`i`和顶点`j`之间不存在一条边。

空间复杂度：`O(n ^ 2)`，`n`为顶点个数

优点：

1. 直观、简单
2. 判断两个顶点是否连接，获取入度和出度以及更新度数，时间复杂度都是`O(1)`

缺点：

1. 如果是稀疏图，会很浪费空间；如果是无向图，至少有50%空间浪费（无向图中，邻接矩阵关于对角线对称）

示例：

```
有 N 个网络节点，标记为 1 到 N。

给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。

现在，我们从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。


示例：

输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2
输出：2

建图代码：

// 初始化二维数组（即邻接矩阵）
const graph = new Array(n).fill(0).map(_ => new Array(n).fill(0));
// 填充图信息
times.forEach(([u, v, w]) => graph[u - 1][v - 1] = w);
```

##### 邻接表方式

对于每个点，存储着一个链表，用来指向所有与该点直接相连的点。对于有权图来说，链表中元素值对应着权重。

```
0 -> 1 -> 3
1 -> 0 -> 2 -> 3
2 -> 1 -> 3 -> 4
3 -> 0 -> 1 -> 2
4 -> 2
```

### 图的遍历（算法思想）

##### 深度优先遍历（Depth First Search, DFS）

深度优先遍历图的方法是：从图中某顶点`v`出发

1. 访问顶点`v`
2. 从`v`的未被访问的邻接点中选取一个顶点`w`，从`w`出发进行深度优先遍历
3. 重复上述两步，知道图中所有与`v`有路径相通的顶点都被访问到

伪代码：

```
let visited = new WeakMap()

function DFS(v) {
  // 记录已访问顶点
  visited[v] = true

  for (v 的每个相邻点 w) {
    if (!visited[w]) {
      DFS(w)
    }
  }
}
```

### 广度优先遍历（Breadth First Search, BFS）

广度优先遍历图的方法是：

1. 顶点`v`加入队列
2. 当队列非空时则继续执行，否则算法结束
3. 出队列取得对头顶点`v`，访问顶点`v`并标记顶点`v`已被访问
4. 查找顶点`v`的第一个邻接顶点`col`
5. 若`v`的邻接顶点`col`未被访问过，则访问并标记`col`，并把`col`加入队列中；若已访问过则跳过
6. 查找顶点`v`的另一个新的邻接顶点`col`，继续步骤5的判断，直到顶点`v`的所有未被访问过的邻接点处理完毕。然后转到步骤2

### 常见算法

#### 最短路径算法

1. Dijkstra 算法（迪杰斯特拉）

算法的基本思想是贪心，每次都遍历所有邻居，并从中找到距离最小的，本质上是一种广度优先遍历。

限制：

1. 单源最短路算法，即只能求出某点到其它点最短距离，并不能得出任意两点之间的最短距离
2. 点与点之间的路径权值不能为负数

算法步骤：

1. 将所有边初始化为无穷大
2. 选择一个开始的顶点，添加到优先队列中
3. 从优先队列中挑选出一个路径值最小的顶点，将其弹出，作为新的顶点
4. 如果该点已被处理过，则跳到步骤3；否则对该点的所有邻接顶点进行判断，如果到该点的距离小于原先的值，则将该值进行更新
5. 将该点所有邻接顶点按照从小到大的顺序添加到优先队列中，并标记该点已被处理过
6. 重复3,4,5步骤，直到所有点都被处理过一次

算法实现：

![dijkstra 算法](./dijkstra.js)


2. Floyd 算法（佛洛伊德算法）

Floyd 算法是一个经典的动态规
划算法，可以求出任意亮点的最短距离。

算法思路：

从任意节点`i`到任意节点`j`的最短路径是：

1. 是直接从`i`到`j` (边界)
2. 是从`i`经过若干节点`k`，再到`j` （状态转移方程: `D(i,j) = D(i,k) + D(k,j)`）
3. 取`D(i,j)`的最小值

![Floyd 算法](./floyd.js)


3. 贝尔曼-福特算法

主要解决单源最短路径，即图中某一点到其他点的最短距离。这点与dijkstra算法类似。

其基本思想也是动态规划。

算法思路：

1. 初始化起始点距离为0
2. 对图中的所有边进行若干次处理，直到文档。处理依据是：对于每一个有向边`g(u,v)`，如果`dist[u] + w < dist[v]`，那么意味着找到了一条达到`v`更近的路，则更新`dist[v]`
3. 上面的若干次的上限是顶点 V 的个数，因此需要进行 n 次处理。
4. 最后检查一下是否存在负边引起的环。

#### 拓扑排序

**有向无环图才有可能进行拓扑排序**

1. Kahn算法

算法思路：

1. 找到所有没有任何父节点的节点（即入度为零的节点），存放到`L`列表中
2. 把与这些节点相连的边从图中去掉，再寻找图中入度为零的节点，对于这些新找到的入度为零的节点，他们的父节点已经在`L`列表中了，所以也可以放到`L`中
3. 重复上述1和2步骤，直到找不到入度为零的节点。如果`L`中元素个数和节点总数相同，说明排序完成。否则说明图中有环，无法进行拓扑排序

![Kahn算法](./kahn.js)

#### 最小生成树

生成树是原图的一个子图，它本质是一棵树，这也是为什么叫做生成树，而不是生成图的原因。其次生成树应该**包括图中所有的顶点**。

最小生成树是在生成树的基础上加了最小关键字，是**最小权重生成树**的简称

计算最小生成树就从边集合中挑选 n - 1 个边，需满足：

- 生成树的要求
- 边的权重值和最小

1. Kruskal 算法

https://segmentfault.com/a/1190000012649227

Kruskal 算法也被形象地称为加边法。

算法思路：

1. 对边按照权重值从小到大排序
2. 将n个顶点初始化为n个联通域
3. 按照权重值从小到大选择边加入结果集，每次贪心地选择最小边。如果当前选择的边与已经选择的边联通了（即出现环），则放弃当前选择的边；否则把当前选择的边加入到结果集
4. 重复3，直到找到一个联通域大小为n的子图（即顶点数为n的子树）

```
// 伪代码
// 结果集
let result = [];

// 从小达到排序
edges = quickSort(edges);
for (let i = 0; i < edges.length; i++) {
  // 记录已选择的边所组成的图形，判断是否形成环图
  if (!isUnionSet(edges[i])) {
    result.push(edges[i])
  }

  // 边的数量是顶点数减1，即包含了所有顶点
  if (result.length === n - 1) {
    return result;
  }
}
```


如何判断环图？(并查集)

1. 顶点记录指向父节点的属性
2. 增加层级，用来区分当前节点作为父节点还是子节点


2. Prim 算法

Prim 算法是一种求解**加权无向连通图**的 MST 问题的贪心算法，也被形象地称为加点法。

算法思想：



为了后面描述方便，我们令 V 为图中的顶点数， E 为图中的边数。那么 KruKal 的算法复杂度是 $O(ElogE)$，Prim 的算法时间复杂度为 $E + VlogV$。因此 Prim 适合适用于稠密图，而 KruKal 则适合稀疏图。
