> 模块化主要是用来抽离公共代码进行复用、隔离作用域、避免变量冲突等

### IIFE 

使用自执行函数来编写模块化代码，特点是：**在一个单独的函数作用域中执行代码，避免变量冲突**

```js
(function() {
  const a = 1
  console.log(a)
})()
```

### AMD 

异步加载模块，代表作 requir.js ，特点是 **强调依赖前置，即依赖需提前声明好**

```js
define('./dep.js', (dep) => {
  // dep就是dep.js模块导出的内容
})
```

### CMD 

与AMD类似，最大区别和特点是CMD强调**延迟加载**，代表作是sea.js（后续require.js也支持延迟加载了）

```js
define(function(require, exports, module) {
  const a = require('./a.js')
})
```

### commonJS

文件即模块，每个文件通过module来表示，用require来引用其他依赖，用module.exports来导出自身

特点：

1. 步加载规范
2. 运行时加载(可以在require里拼接变量，在加载时会自动识别出最终的实际路径)

### UMD

兼容AMD，CommonJS 模块化语法，比如通常我们使用webpack打包出的生产js文件

### ES Modules

通过import引入依赖，通过export导出依赖

ES6的模块机制在依赖模块时并不会先去预加载整个脚本，而是生成一个只读引用，并且静态解析依赖，等到执行代码时，再去依赖里取出实际需要的模块

特点：

1. 编译时加载，不允许在里边引用变量，必须为真实的文件路径。
2. 可以通过调用import()语句，会生成一个promise去加载对应的文件，这样子就是运行时加载，可以在路径里边编写变量
