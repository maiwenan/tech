## 状态更新

### 创建 Update 对象

React 中，有以下方法可以更新状态：

- ReactDOM.render() ---- HostRoot
- this.setState() ---- ClassComponent
- this.forceUpdate() ---- ClassComponent
- useState() ---- FunctionComponent
- useReducer() ---- FunctionComponent

一共三种组件（HostRoot | ClassComponent | FunctionComponent）可以触发更新。

由于不同类型组件工作方式不同，所以存在两种不同结构的Update，其中ClassComponent与HostRoot共用一套Update结构，FunctionComponent单独使用一种Update结构

每次**状态更新**都会创建一个保存**更新状态相关内容**的对象，叫做`Update`对象。在`render`阶段的`beginWork`中会根据`Update`计算新的`state`。

**状态更新**整个调用路径的关键节点：
```

触发状态更新（根据不同场景调用不通的方法）

    |
    |
    v

创建Update对象

    |
    |
    v

从fiber到root（`markUpdateLaneFromFiberToRoot`）

    |
    |
    v

调度更新（`ensureRootIsScheduled`）

    |
    |
    v

render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）

    |
    |
    v

commit阶段（`commitRoot`）
```

### 同步更新的React

通过`ReactDOM.render`创建的应用都是同步更新状态，即没有优先级概念，所有状态更新都要等上一次状态更新完成才能开始本次状态更新。

### 并发更新的React

通过`ReactDOM.createBlockingRoot`和`ReactDOM.createRoot`创建的应用会采用**并发**的方式更新状态。即高优先的更新可以中断正在进行的低优先级更新，先完成`render - commit`的流程，等高优先级更新完成后，低优先级更新基于高优先级更新的结果重新更新。

### Update 的结构

ClassComponent与HostRoot（即`rootFiber.tag`对应类型）共用同一种`Update`结构，如下：

```
const udpate: Update<*> = {
  // 任务时间，通过performance.now()获取的毫秒数
  eventTime,
  // 优先级
  lane,
  // Suspense相关配置
  suspenseConfig,
  // 更新的类型，包括 UpdateState | ReplaceState | ForceUpdate | CaptureUpdate
  tag: UpdateState,
  // 更新挂在的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参
  payload: null,
  // 更新的回调函数
  callback: null,
  // 与其他`Update`连接形成链表，即同一个fiber节点上的多个Update对象可通过该属性连接在一起（多次调用更新状态的方法可以创建多个Update对象）
  next: null,
}
```

Fiber节点上的多个`Update`会组成链表并被包含在`fiber.updateQueue`中。

### updateQueue

`updateQueue`有三种类型，其中`ClassComponent`与`HostRoot`使用的`UpdateQueue`结构如下：

```
const queue: UpdateQueue<State> = {
  // 本次更新前该fiber节点的state，`Update`基于该state计算更新后的state
  baseState: fiber.memorizedState,
  firstBaseUpdate: null,
  lastBaseUpdate: null,
  shared: {
    // 触发更新时，产生的`Update`会保存在shared.pending中形成单向环状链表
    // shared.pending 会保证始终指向最后一个插入的update
    pending: null
  },
  // 保存`update.callback !== null`的`Update`
  effets: null
};
```
`firstBaseUpdate`与`lastBaseUpdate`：本次更新前该Fiber节点已保存的`Update`。以链表形式存在，链表头为firstBaseUpdate，链表尾为lastBaseUpdate。之所以在更新产生前该Fiber节点内就存在Update，是由于某些Update优先级较低所以在上次render阶段由Update计算state时被跳过。

### ReactDOM.render 工作流程

ReactDOM.render的流程:

```
创建fiberRootNode、rootFiber和初始化updateQueue（通过调用`legacyCreateRootFromDOMContainer`方法）

    |
    |
    v

创建Update对象（通过调用`updateContainer`方法）

    |
    |
    v

从fiber到root（通过调用`markUpdateLaneFromFiberToRoot`方法）

    |
    |
    v

调度更新（通过调用`ensureRootIsScheduled`方法）

    |
    |
    v

render阶段（通过调用`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`方法）

    |
    |
    v

commit阶段（通过调用`commitRoot`方法）
```

### this.setState 工作流程

